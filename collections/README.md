# Collection in Rust

러스트의 표준 라이브러리에는 컬렉션이라 불리는 여러 개의 매우 유용한 데이터 구조들이 포함되어 있다.

대부분의 다른 데이터 타입들은 하나의 특정한 값을 나타내지만, 컬렉션은 다수의 값을 담을 수 있다.

내장된 배열(build-in array)와 튜플 타입과는 달리, 이 컬렉션들이 가리키고 있는 데이터들은 힙에 저장되는데,

이는 즉 데이터량이 컴파일 타임에 결정되지 않아도 되며 프로그램이 실행될 때 늘어나거나 줄어들 수 있다는 의미다.

각각의 컬렉션 종류는 서로 다른 용량과 비용을 가지고 있다.

벡터(vector) 는 여러 개의 값을 서로 붙어 있게 저장할 수 있도록 해준다.
스트링(string) 은 문자(character)의 모음이다.
해쉬맵(hash map) 은 어떤 값을 특정한 키와 연관지어 주도록 해준다.

## 벡터

### Create vector

```rust
let v: Vec<i32> = Vec::new();
```

위 코드는 i32 타입을 가질 수 있는 비어있는 새 벡터를 생성해준다.

벡터를 만들 때는 반드시 어떤 타입을 저장하고자 하는 지 컴파일러가 알 수 있도록 명시해주어야 한다.

```Rust
let v = vec![1, 2, 3, 4, 5];
```

초기에 타입을 명시해두었기 때문에, 위와 같이 값을 저장한 벡터를 v와 묶을 수 있다.

### Update vector

```Rust
let mut v: Vec<i32> = Vec::new();

// push 메소드 이용하여 vector에 요소 추가
v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

### Drop vector

```rust
{
	let v  = Vec::new();

	// v를 이용한 로직...
} // 스코프가 끝나면서 v와 v안의 요소들 또한 모두 drop된다.
```

### Read vector

아래는 벡터 내의 요소의 값을 참조하는 두 가지 방법이다.

타입을 명시해주는 것은 귀찮지만 개발자가 더 명시적으로 알아볼 수 있게 해준다.

```Rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
let third: Option<&i32> = v.get(2);
```

러스트에서 벡터 내의 값에 접근하는 방법으로 두 방법을 제공하는 것은

개발자로 하여금 벡터 내에 존재하지 않는 인덱스를 사용하고자 했을 때

프로그램이 어떻게 동작할 것인지 선택할 수 있도록 하고자 함이다.

```Rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

위와 같은 상황에서, 첫 번째 []를 이용한 접근은 panic!을 일으킨다.

벡터의 끝을 넘어서는 요소에 접근을 시도할 경우 강제적으로 프로그램을 죽이고 싶을 때 쓰면 유용하다.

반면 get()함수를 이용한 접근에서는 None 타입이 반환된다.

종료시키는 것 대신 None을 뱉어내면서 그에 따른 로직을 수행하고 싶을 때 유용할 것이다.

### 유효하지 않은 reference

아래의 예시를 보면

```rust
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);
```

first 변수가 v의 0번째 요소를 참조한다.

하지만 이런 경우, 같은 스코프 내에서 가변 참조자와 불변 참조자를 동시에 얻게 된다.

불변참조자 first를 선언한 밑 줄에서 v에 요소를 추가하는데, 이는 컴파일 에러를 발생시킨다.

새로운 요소를 벡터의 끝에 추가하는 것은 새로 메모리를 할당하여 예전 요소를 새 공간에 복사하는 일을 필요로 할 수 있는데,

이는 벡터가 모든 요소들을 붙여서 저장할 공간이 충분치 않는 환경에서 일어날 수 있다.

이러한 경우, 첫번째 요소에 대한 참조자는 할당이 해제된 메모리를 가리키게 된다.

러스트의 빌림 규칙은 프로그램이 이러한 상황에 빠지지 않도록 해준다.

### 벡터 내의 값들에 대한 반복 처리

```rust
let v = vec![1, 2, 3, 4, 5];

for i in &v {
	println!("{}", *i);
}
```

mutation 예제

```Rust
let mut v = vec![1, 2, 3, 4, 5];
for i in &mut v {
	*i += 50;
}
```
