# 소유권 Ownership

## Rust에서의 소유권

러스트의 핵심기능은 바로 소유권이다. 

러스트는 메모리 관리에서 가비지 컬렉터를 대체하는 방식으로 소유권이라는 제 3의 접근법을 이용했다.

---

### 소유권 규칙 

러스트에서 말하는 소유권 규칙 3 가지가 있다. 

1. 러스트의 각각의 값은 해당값의 오너라고 불리우는 변수를 갖고 있다.
2. 한번에 딱 하나의 오너만 존재할 수 있다.
3. 오너가 스코프 밖으로 벗어나는 때, 값은 버려진다.

---

### 변수의 스코프

```rust

fn main() {
    // s는 아직 선언되지 않아 유효하지 않다. 
    let s = "hello";
    // s는 이 지점부터 유효하다.
} // 이 스코프는 이제 끝이므로, s는 유효하지 않다.

```
** 스코프 안에서 변수가 등장하면, 유효하다.
** 이 유효기간은 스코프 밖으로 벗어날 때까지 지속된다.

---

### String 타입

스택에 저장되는 데이터가 아니라, 힙에 저장되는 데이터를 관찰하고,

러스트는 어떻게 이 데이터를 비워내는지 알 필요가 있다.

String 리터럴의 값은 프로그램 안에 하드코딩 되어있다. 

문자열 값은 편리하지만, 모든 경우에 항상 적절하지는 않다. 

문자열 값은 불변이고, 모든 문자열이 우리가 프로그래밍 하는 시점에서 다 알 수 있는 것이 아니란 점이다.

예를 들면 입력을 받아 저장하고 싶을 수 있다. 

```rust
let s = String::from("hello");
// ::(더블 콜론)은 String 타입 아래의 from 함수를 특정지을 수 있도록 해주는 네임스페이스 연산자이다. 
```

<br />

```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str은 해당 스트링 리터럴을 스트링에 붙여준다.

println!("{}", s);
```

같은 구문처럼 보이지만 mutation이 들어가지 않으면 컴파일 에러가 발생한다. 

String 타입은 변경 가능하고 커질 수 있는 텍스트를 지원하기 위해 만들어졌고, 

우리는 힙에서 컴파일 타임에는 알 수 없는 어느 정도 크기의 공간을 할당받아 내용물을 저장한다.

** 런타임에 OS로 부터 메모리가 요청되어야 한다.
** String의 사용이 끝났을 때 운영체제에게 메모리를 반납할 방법이 필요하다. 

String::from으로 우리가 메모리를 요청하면, 구현부분에서 필요한 만큼의 메모리가 요청된다.

이렇게 선언된 변수가 스코프 밖으로 벗어나면, 러스트는 drop이라는 함수를 호출해 String의 메모리를 반환하도록 하는 코드를 집어넣을 수 있다. } 괄호가 닫힐 때 러스트는 자동적으로 drop을 호출한다.

---

### 변수와 데이터가 상호작용하는 방법 : 이동(move)

```rust

let x = 5;
let y = x;
```

정수값 5를 x에 묶어놓고, x의 값의 복사본을 만들어 y에 묶는다. 

5라는 값은 스택에 푸쉬될 것이다. 

String 버전은 어떨까? 

```rust
let s1 = String::from("Hello");
let s2 = s1;
```

이 코드는 이전 코드와 완전히 다르게 동작한다.

s1은 문자열의 시작을 가리키는 포인터이고, s1의 내용 hello는 힙에 저장된다.

스택에는 s1이 가리키는 주소, 길이, 용량이 담긴 String 변수가 저장될 것이다.

s2는 s1의 포인터, 길이, 용량을 복사하지만, 힙 메모리 상의 데이터는 복사되지 않는다. 

또한, s2로 s1의 정보가 이동하면서, 러스트에서는 이런 경우 s1을 유효하지 않다고 간주한다.

```rust
let s1 = String::from("Hello");
let s2 = s1;

println!("{}, world!", s1);
// Error ! value used here after move
```

다른 언어에서의 얕은 복사와는 다르게, 복사를 하고 첫 번째 변수를 무효화 시키기 때문에

러스트에서는 이를 이동(move)라고 부른다.

---

### 변수와 데이터가 상호작용하는 방법: 클론

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone();
    println!("s1 = {}, s2 = {}", s1, s2);
}
```

힙 데이터도 깊은 복사하기를 원한다면 clone 메소드를 사용하면 된다.

---

### 스택에만 있는 데이터: 복사

```rust
let x = 5;
let y = x;

println!("x = {}, y = {}", x, y);
```

위 코드는 clone을 이용하지 않지만 x도 유효하며 y로 이동하지도 않는다. 

정수형과 같이 컴파일 타임에 결졍되어 있는 크기의 타입은 스택에 모두 저장되기 때문에, 

실제 값의 복사본이 빠르게 만들어질 수 있다. 

그렇기 때문에 y가 생성된 후에 x를 무효화할 이유가 없다.

---

### 소유권과 함수

```rust
fn main() {
    let s = String::from("hello");  // s가 스코프 안으로 들어왔습니다.

    takes_ownership(s);             // s의 값이 함수 안으로 이동했습니다...
                                    // ... 그리고 이제 더이상 유효하지 않습니다.
    let x = 5;                      // x가 스코프 안으로 들어왔습니다.

    makes_copy(x);                  // x가 함수 안으로 이동했습니다만,
                                    // i32는 Copy가 되므로, x를 이후에 계속
                                    // 사용해도 됩니다.

} // 여기서 x는 스코프 밖으로 나가고, s도 그 후 나갑니다. 하지만 s는 이미 이동되었으므로,
  // 별다른 일이 발생하지 않습니다.

fn takes_ownership(some_string: String) { // some_string이 스코프 안으로 들어왔습니다.
    println!("{}", some_string);
} // 여기서 some_string이 스코프 밖으로 벗어났고 `drop`이 호출됩니다. 메모리는
  // 해제되었습니다.

fn makes_copy(some_integer: i32) { // some_integer이 스코프 안으로 들어왔습니다.
    println!("{}", some_integer);
} // 여기서 some_integer가 스코프 밖으로 벗어났습니다. 별다른 일은 발생하지 않습니다.
```

s를 takes_ownership이 실행된 이후 사용하려 하면 컴파일 타임 오류가 날 것이다. 

함수 스코프에 따른 반환 값의 예제를 하나 더 보자.

```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership은 반환값을 s1에게
                                        // 이동시킵니다.

    let s2 = String::from("hello");     // s2가 스코프 안에 들어왔습니다.

    let s3 = takes_and_gives_back(s2);  // s2는 takes_and_gives_back 안으로
                                        // 이동되었고, 이 함수가 반환값을 s3으로도
                                        // 이동시켰습니다.

} // 여기서 s3는 스코프 밖으로 벗어났으며 drop이 호출됩니다. s2는 스코프 밖으로
  // 벗어났지만 이동되었으므로 아무 일도 일어나지 않습니다. s1은 스코프 밖으로
  // 벗어나서 drop이 호출됩니다.

fn gives_ownership() -> String {             // gives_ownership 함수가 반환 값을
                                             // 호출한 쪽으로 이동시킵니다.

    let some_string = String::from("hello"); // some_string이 스코프 안에 들어왔습니다.

    some_string                              // some_string이 반환되고, 호출한 쪽의
                                             // 함수로 이동됩니다.
}

// takes_and_gives_back 함수는 String을 하나 받아서 다른 하나를 반환합니다.
fn takes_and_gives_back(a_string: String) -> String { // a_string이 스코프
                                                      // 안으로 들어왔습니다.

    a_string  // a_string은 반환되고, 호출한 쪽의 함수로 이동됩니다.
}
```